"(30.69,59.38]",
"(59.38,89.06]",
"(89.06,118.75]"))
summary(df$c.MonthlyCharges)
par(mfrow=c(1,2))
plot(df$c.MonthlyCharges, main = "Barplot of df$c.MonthlyCharges")
hist(df$MonthlyCharges)
par(mfrow=c(1,1))
# Chunk 9
# The only numerical features that we have are tenure, MonthlyCharges and TotalChages.
numeric_val_idx = which(sapply(df, is.numeric))
numeric_val = names(df)[numeric_val_idx]
# So the remaining will be categorical features.
categoric_val_idx = which(sapply(df, is.factor))
categoric_val = names(df)[categoric_val_idx]
# Chunk 10
# EDA for each variable (numeric and graphic)
summary(df)
# The plot of all variables can be seen in the report
#create_report(df, output_file = "Telco.html")
# In the report we can see that no numeric variable has a normal distribution,
# so there is no need to perform any test on their normality.
# Chunk 11
# Distribution of missings in df
apply(sapply(df, is.na), 2, sum)
# Only TotalCharges and hence c.TotalCharges have missings values, 22 in total.
# Chunk 12
# We can check if there are inconsistencies in total charges. That is the only
# variable that could have any.
# First, let's compute the expected total charges as the product of monthly
# charges and tenure
expected_total_charges = df$MonthlyCharges * df$tenure
# Then plot them against the actual total charges
plot(expected_total_charges, df$TotalCharges)
# There are no outliers, so TotalCharges is consistent.
# Chunk 13
# Outliers
for (var in as.numeric(numeric_val_idx)) {
Boxplot(df[,var], ylab = names(df)[var], main = "Boxplot")
}
# There aren't univariate outliers
# Chunk 14
# Distribution of missings
table(apply(sapply(df, is.na), 1, sum))
# As could be deduced from the distribution of missings per variable, only
# eleven records have missings. Precisely, these individuals have an na value
# for TotalCharges and c.TotalCharges. We can find them.
which(is.na(df$TotalCharges))
# Chunk 15
df$n.na <- apply(sapply(df, is.na), 1, sum)
df$n.outliers <- rep(0,dim(df)[1])
df$n.errors <- rep(0,dim(df)[1])
# Chunk 16
# c.TotalCharges has missings, so it doesn't make sense to compute the mean
# of missings in its categories
interesting_cat_idx <- categoric_val_idx[-c(1,20)]
k = 0
for (i in interesting_cat_idx){
k <- k + length(levels(df[,i]))
}
groups.na <- matrix(0, k, 2)
l = 1
for (i in seq(length(interesting_cat_idx))) {
idx <- interesting_cat_idx[i]
categories.na <- tapply(df$n.na, df[,idx], mean)
for (j in seq(length(categories.na))) {
groups.na[l + j - 1,] <- c(as.numeric(categories.na[j]),
paste(names(df)[idx], levels(df[,idx])[j],
sep = "."))
}
l <- l + j
}
groups.na.df <- data.frame(na.perc = groups.na[,1], group = groups.na[,2])
groups.na.df[order(groups.na.df$na.perc, decreasing = TRUE),]
# Chunk 17
TotalCharges.na <- which(is.na(df$TotalCharges))
sum(TotalCharges.na == which(df$tenure == 0)) == length(TotalCharges.na)
# Individuals with missing TotalCharges correspond to those whose tenure is 0,
# which means they are recently joined clients.
# In this situation, instead of NA, we can convert them to 0.
na.idx <- which(is.na(df$TotalCharges))
df$TotalCharges[na.idx] = 0
df$c.TotalCharges[na.idx] = "(-1,2171]"
# Now there are no more missing values
summary(df)
# Chunk 18
# Let's look at the correlation between our variables, specially between
# the ones created for the data quality report and the rest of them.
corr_mat <- cor(df[,c(numeric_val_idx, 25)],)
corr_mat
corrplot(corr_mat, order = 'hclust')
# n.na isn't related to any other variable. However, TotalCharges is both
# related to tenure and MonthlyCharges. We already saw this phenomenon when
# we ploted TotalCharges against tenure*MonthlyCharges.
# Chunk 19
# Let's look for multiavariant outliers
set.seed(123)
res.mout <- Moutlier(df[,numeric_val_idx], quantile = 0.95, plot= FALSE)
par(mfrow=c(1,2))
plot(res.mout$md, col="lightblue", pch = 19, main = 'Detection of multivariable
outliers', xlab= 'Observation',
ylab ='Traditional Mahalanobis distance ')
abline(h = res.mout$cutoff, col = "red", lwd = 5, lty = 2)
plot(res.mout$rd, col="lightblue", pch = 19, xlab= 'Observation',
ylab ='Robust Mahalanobis distance ')
abline(h = res.mout$cutoff, col = "red", lwd = 5, lty = 2)
par(mfrow=c(1,1))
outliers = which(res.mout$md>res.mout$cutoff & res.mout$rd > res.mout$cutoff)
length(outliers)
length(outliers)/dim(df)[1]*100
# There are 344 multivariant outliers, about 5% of the individuals.
# Chunk 20
# After the report, we remove the newly created variables to don't interfere
# in the rest of the project
df$n.na <- NULL
df$n.errors <- NULL
df$n.outliers <- NULL
profiling(df[-1], df$Churn, "Churn")
profiling(df[-1], df$Churn, "Churn")
summary(df$c.MonthlyCharges)
1634/dim(df)[1]
2317/dim(df)[1]
table(df$Churn, df$gender)
prop.table(table(df$Churn, df$gender))
prop.table(table(df$Churn, df$gender),1)
prop.table(table(df$Churn, df$gender),2)
?prop.table
profiling(df[-1], df$Churn, "Churn")
# Chunk 1
# Clean the workspace
if(!is.null(dev.list())) dev.off()
rm(list = ls())
# Chunk 2
# Import the libraries and other sources
library(dplyr)
library(car)
library(DataExplorer)
library(FactoMineR)
library(caTools)
library(chemometrics)
source("profiling_func.R")
# Chunk 3
# Import the dataset
df = read.csv("WA_Fn-UseC_-Telco-Customer-Churn.xls",header=T, sep=",",
stringsAsFactors=TRUE)
str(df)
summary(df)
# Chunk 4
# SeniorCitizen represents a qualitative concept, so we convert it to factor
df$SeniorCitizen <- factor(df$SeniorCitizen, labels = c("Yes", "No"))
# Chunk 5
# Discretize numerical variables
# tenure
df$c.tenure <- df$tenure
m.tenure <- max(df$tenure, na.rm = TRUE)
df$c.tenure <- replace(df$c.tenure, df$tenure <= m.tenure/4, m.tenure/4)
for (i in 1:3) {
idx <- (m.tenure*i/4 < df$tenure) & (df$tenure <= m.tenure*(i+1)/4)
df$c.tenure <- replace(df$c.tenure, idx, m.tenure*(i+1)/4)
}
min(df$tenure, na.rm = TRUE)
breakpts <- seq(m.tenure/4, m.tenure, m.tenure/4); breakpts
df$c.tenure <- factor(df$c.tenure, labels = c("(-1,18]", "(18,36]",
"(36,54]", "(54,72]"))
summary(df$c.tenure)
par(mfrow=c(1,2))
plot(df$c.tenure, main = "Barplot of df$c.tenure")
hist(df$tenure)
# Chunk 6
# TotalCharges
df$c.TotalCharges <- df$TotalCharges
m.TotalCharges <- max(df$TotalCharges, na.rm = TRUE)
df$c.TotalCharges <- replace(df$c.TotalCharges, df$TotalCharges <= m.TotalCharges/4, m.TotalCharges/4)
for (i in 1:3) {
idx <- (m.TotalCharges*i/4 < df$TotalCharges) & (df$TotalCharges <=
m.TotalCharges*(i+1)/4)
df$c.TotalCharges <- replace(df$c.TotalCharges, idx, m.TotalCharges*(i+1)/4)
}
breakpts <- seq(m.TotalCharges/4, m.TotalCharges, m.TotalCharges/4); breakpts
df$c.TotalCharges <- factor(df$c.TotalCharges, labels = c("(-1,2171]",
"(2171,4342]",
"(4342,6514]",
"(6514,8685]"))
summary(df$c.TotalCharges)
par(mfrow=c(1,2))
plot(df$c.TotalCharges, main = "Barplot of df$c.TotalCharges")
hist(df$TotalCharges)
# Chunk 7
# MonthlyCharges
df$c.MonthlyCharges <- df$MonthlyCharges
m.MonthlyCharges <- max(df$MonthlyCharges, na.rm = TRUE)
df$c.MonthlyCharges <- replace(df$c.MonthlyCharges, df$MonthlyCharges <= m.MonthlyCharges/4, m.MonthlyCharges/4)
for (i in 1:3) {
idx <- (m.MonthlyCharges*i/4 < df$MonthlyCharges) & (df$MonthlyCharges <=
m.MonthlyCharges*(i+1)/4)
df$c.MonthlyCharges <- replace(df$c.MonthlyCharges, idx,
m.MonthlyCharges*(i+1)/4)
}
min(df$MonthlyCharges, na.rm = TRUE)
breakpts <- seq(m.MonthlyCharges/4, m.MonthlyCharges, m.MonthlyCharges/4)
breakpts
df$c.MonthlyCharges <- factor(df$c.MonthlyCharges, labels = c("(18,30.69]",
"(30.69,59.38]",
"(59.38,89.06]",
"(89.06,118.75]"))
summary(df$c.MonthlyCharges)
par(mfrow=c(1,2))
plot(df$c.MonthlyCharges, main = "Barplot of df$c.MonthlyCharges")
hist(df$MonthlyCharges)
par(mfrow=c(1,1))
# Chunk 9
# The only numerical features that we have are tenure, MonthlyCharges and TotalChages.
numeric_val_idx = which(sapply(df, is.numeric))
numeric_val = names(df)[numeric_val_idx]
# So the remaining will be categorical features.
categoric_val_idx = which(sapply(df, is.factor))
categoric_val = names(df)[categoric_val_idx]
# Chunk 10
# EDA for each variable (numeric and graphic)
summary(df)
# The plot of all variables can be seen in the report
#create_report(df, output_file = "Telco.html")
# In the report we can see that no numeric variable has a normal distribution,
# so there is no need to perform any test on their normality.
# Chunk 11
# Distribution of missings in df
apply(sapply(df, is.na), 2, sum)
# Only TotalCharges and hence c.TotalCharges have missings values, 22 in total.
# Chunk 12
# We can check if there are inconsistencies in total charges. That is the only
# variable that could have any.
# First, let's compute the expected total charges as the product of monthly
# charges and tenure
expected_total_charges = df$MonthlyCharges * df$tenure
# Then plot them against the actual total charges
plot(expected_total_charges, df$TotalCharges)
# There are no outliers, so TotalCharges is consistent.
# Chunk 13
# Outliers
for (var in as.numeric(numeric_val_idx)) {
Boxplot(df[,var], ylab = names(df)[var], main = "Boxplot")
}
# There aren't univariate outliers
# Chunk 14
# Distribution of missings
table(apply(sapply(df, is.na), 1, sum))
# As could be deduced from the distribution of missings per variable, only
# eleven records have missings. Precisely, these individuals have an na value
# for TotalCharges and c.TotalCharges. We can find them.
which(is.na(df$TotalCharges))
# Chunk 15
df$n.na <- apply(sapply(df, is.na), 1, sum)
df$n.outliers <- rep(0,dim(df)[1])
df$n.errors <- rep(0,dim(df)[1])
# Chunk 16
# c.TotalCharges has missings, so it doesn't make sense to compute the mean
# of missings in its categories
interesting_cat_idx <- categoric_val_idx[-c(1,20)]
k = 0
for (i in interesting_cat_idx){
k <- k + length(levels(df[,i]))
}
groups.na <- matrix(0, k, 2)
l = 1
for (i in seq(length(interesting_cat_idx))) {
idx <- interesting_cat_idx[i]
categories.na <- tapply(df$n.na, df[,idx], mean)
for (j in seq(length(categories.na))) {
groups.na[l + j - 1,] <- c(as.numeric(categories.na[j]),
paste(names(df)[idx], levels(df[,idx])[j],
sep = "."))
}
l <- l + j
}
groups.na.df <- data.frame(na.perc = groups.na[,1], group = groups.na[,2])
groups.na.df[order(groups.na.df$na.perc, decreasing = TRUE),]
# Chunk 17
TotalCharges.na <- which(is.na(df$TotalCharges))
sum(TotalCharges.na == which(df$tenure == 0)) == length(TotalCharges.na)
# Individuals with missing TotalCharges correspond to those whose tenure is 0,
# which means they are recently joined clients.
# In this situation, instead of NA, we can convert them to 0.
na.idx <- which(is.na(df$TotalCharges))
df$TotalCharges[na.idx] = 0
df$c.TotalCharges[na.idx] = "(-1,2171]"
# Now there are no more missing values
summary(df)
# Chunk 18
# Let's look at the correlation between our variables, specially between
# the ones created for the data quality report and the rest of them.
corr_mat <- cor(df[,c(numeric_val_idx, 25)],)
corr_mat
corrplot(corr_mat, order = 'hclust')
# n.na isn't related to any other variable. However, TotalCharges is both
# related to tenure and MonthlyCharges. We already saw this phenomenon when
# we ploted TotalCharges against tenure*MonthlyCharges.
# Chunk 19
# Let's look for multiavariant outliers
set.seed(123)
res.mout <- Moutlier(df[,numeric_val_idx], quantile = 0.95, plot= FALSE)
par(mfrow=c(1,2))
plot(res.mout$md, col="lightblue", pch = 19, main = 'Detection of multivariable
outliers', xlab= 'Observation',
ylab ='Traditional Mahalanobis distance ')
abline(h = res.mout$cutoff, col = "red", lwd = 5, lty = 2)
plot(res.mout$rd, col="lightblue", pch = 19, xlab= 'Observation',
ylab ='Robust Mahalanobis distance ')
abline(h = res.mout$cutoff, col = "red", lwd = 5, lty = 2)
par(mfrow=c(1,1))
outliers = which(res.mout$md>res.mout$cutoff & res.mout$rd > res.mout$cutoff)
length(outliers)
length(outliers)/dim(df)[1]*100
# There are 344 multivariant outliers, about 5% of the individuals.
# Chunk 20
# After the report, we remove the newly created variables to don't interfere
# in the rest of the project
df$n.na <- NULL
df$n.errors <- NULL
df$n.outliers <- NULL
profiling(df[-1], df$Churn, "Churn")
# Chunk 1
# Clean the workspace
if(!is.null(dev.list())) dev.off()
rm(list = ls())
# Chunk 2
# Import the libraries and other sources
library(dplyr)
library(car)
library(DataExplorer)
library(FactoMineR)
library(caTools)
library(chemometrics)
source("profiling_func.R")
# Chunk 3
# Import the dataset
df = read.csv("WA_Fn-UseC_-Telco-Customer-Churn.xls",header=T, sep=",",
stringsAsFactors=TRUE)
str(df)
summary(df)
# Chunk 4
# SeniorCitizen represents a qualitative concept, so we convert it to factor
df$SeniorCitizen <- factor(df$SeniorCitizen, labels = c("Yes", "No"))
# Chunk 5
# Discretize numerical variables
# tenure
df$c.tenure <- df$tenure
m.tenure <- max(df$tenure, na.rm = TRUE)
df$c.tenure <- replace(df$c.tenure, df$tenure <= m.tenure/4, m.tenure/4)
for (i in 1:3) {
idx <- (m.tenure*i/4 < df$tenure) & (df$tenure <= m.tenure*(i+1)/4)
df$c.tenure <- replace(df$c.tenure, idx, m.tenure*(i+1)/4)
}
min(df$tenure, na.rm = TRUE)
breakpts <- seq(m.tenure/4, m.tenure, m.tenure/4); breakpts
df$c.tenure <- factor(df$c.tenure, labels = c("(-1,18]", "(18,36]",
"(36,54]", "(54,72]"))
summary(df$c.tenure)
par(mfrow=c(1,2))
plot(df$c.tenure, main = "Barplot of df$c.tenure")
hist(df$tenure)
# Chunk 6
# TotalCharges
df$c.TotalCharges <- df$TotalCharges
m.TotalCharges <- max(df$TotalCharges, na.rm = TRUE)
df$c.TotalCharges <- replace(df$c.TotalCharges, df$TotalCharges <= m.TotalCharges/4, m.TotalCharges/4)
for (i in 1:3) {
idx <- (m.TotalCharges*i/4 < df$TotalCharges) & (df$TotalCharges <=
m.TotalCharges*(i+1)/4)
df$c.TotalCharges <- replace(df$c.TotalCharges, idx, m.TotalCharges*(i+1)/4)
}
breakpts <- seq(m.TotalCharges/4, m.TotalCharges, m.TotalCharges/4); breakpts
df$c.TotalCharges <- factor(df$c.TotalCharges, labels = c("(-1,2171]",
"(2171,4342]",
"(4342,6514]",
"(6514,8685]"))
summary(df$c.TotalCharges)
par(mfrow=c(1,2))
plot(df$c.TotalCharges, main = "Barplot of df$c.TotalCharges")
hist(df$TotalCharges)
# Chunk 7
# MonthlyCharges
df$c.MonthlyCharges <- df$MonthlyCharges
m.MonthlyCharges <- max(df$MonthlyCharges, na.rm = TRUE)
df$c.MonthlyCharges <- replace(df$c.MonthlyCharges, df$MonthlyCharges <= m.MonthlyCharges/4, m.MonthlyCharges/4)
for (i in 1:3) {
idx <- (m.MonthlyCharges*i/4 < df$MonthlyCharges) & (df$MonthlyCharges <=
m.MonthlyCharges*(i+1)/4)
df$c.MonthlyCharges <- replace(df$c.MonthlyCharges, idx,
m.MonthlyCharges*(i+1)/4)
}
min(df$MonthlyCharges, na.rm = TRUE)
breakpts <- seq(m.MonthlyCharges/4, m.MonthlyCharges, m.MonthlyCharges/4)
breakpts
df$c.MonthlyCharges <- factor(df$c.MonthlyCharges, labels = c("(18,30.69]",
"(30.69,59.38]",
"(59.38,89.06]",
"(89.06,118.75]"))
summary(df$c.MonthlyCharges)
par(mfrow=c(1,2))
plot(df$c.MonthlyCharges, main = "Barplot of df$c.MonthlyCharges")
hist(df$MonthlyCharges)
par(mfrow=c(1,1))
# Chunk 9
# The only numerical features that we have are tenure, MonthlyCharges and TotalChages.
numeric_val_idx = which(sapply(df, is.numeric))
numeric_val = names(df)[numeric_val_idx]
# So the remaining will be categorical features.
categoric_val_idx = which(sapply(df, is.factor))
categoric_val = names(df)[categoric_val_idx]
# Chunk 10
# EDA for each variable (numeric and graphic)
summary(df)
# The plot of all variables can be seen in the report
#create_report(df, output_file = "Telco.html")
# In the report we can see that no numeric variable has a normal distribution,
# so there is no need to perform any test on their normality.
# Chunk 11
# Distribution of missings in df
apply(sapply(df, is.na), 2, sum)
# Only TotalCharges and hence c.TotalCharges have missings values, 22 in total.
# Chunk 12
# We can check if there are inconsistencies in total charges. That is the only
# variable that could have any.
# First, let's compute the expected total charges as the product of monthly
# charges and tenure
expected_total_charges = df$MonthlyCharges * df$tenure
# Then plot them against the actual total charges
plot(expected_total_charges, df$TotalCharges)
# There are no outliers, so TotalCharges is consistent.
# Chunk 13
# Outliers
for (var in as.numeric(numeric_val_idx)) {
Boxplot(df[,var], ylab = names(df)[var], main = "Boxplot")
}
# There aren't univariate outliers
# Chunk 14
# Distribution of missings
table(apply(sapply(df, is.na), 1, sum))
# As could be deduced from the distribution of missings per variable, only
# eleven records have missings. Precisely, these individuals have an na value
# for TotalCharges and c.TotalCharges. We can find them.
which(is.na(df$TotalCharges))
# Chunk 15
df$n.na <- apply(sapply(df, is.na), 1, sum)
df$n.outliers <- rep(0,dim(df)[1])
df$n.errors <- rep(0,dim(df)[1])
# Chunk 16
# c.TotalCharges has missings, so it doesn't make sense to compute the mean
# of missings in its categories
interesting_cat_idx <- categoric_val_idx[-c(1,20)]
k = 0
for (i in interesting_cat_idx){
k <- k + length(levels(df[,i]))
}
groups.na <- matrix(0, k, 2)
l = 1
for (i in seq(length(interesting_cat_idx))) {
idx <- interesting_cat_idx[i]
categories.na <- tapply(df$n.na, df[,idx], mean)
for (j in seq(length(categories.na))) {
groups.na[l + j - 1,] <- c(as.numeric(categories.na[j]),
paste(names(df)[idx], levels(df[,idx])[j],
sep = "."))
}
l <- l + j
}
groups.na.df <- data.frame(na.perc = groups.na[,1], group = groups.na[,2])
groups.na.df[order(groups.na.df$na.perc, decreasing = TRUE),]
# Chunk 17
TotalCharges.na <- which(is.na(df$TotalCharges))
sum(TotalCharges.na == which(df$tenure == 0)) == length(TotalCharges.na)
# Individuals with missing TotalCharges correspond to those whose tenure is 0,
# which means they are recently joined clients.
# In this situation, instead of NA, we can convert them to 0.
na.idx <- which(is.na(df$TotalCharges))
df$TotalCharges[na.idx] = 0
df$c.TotalCharges[na.idx] = "(-1,2171]"
# Now there are no more missing values
summary(df)
# Chunk 18
# Let's look at the correlation between our variables, specially between
# the ones created for the data quality report and the rest of them.
corr_mat <- cor(df[,c(numeric_val_idx, 25)],)
corr_mat
corrplot(corr_mat, order = 'hclust')
# n.na isn't related to any other variable. However, TotalCharges is both
# related to tenure and MonthlyCharges. We already saw this phenomenon when
# we ploted TotalCharges against tenure*MonthlyCharges.
# Chunk 19
# Let's look for multiavariant outliers
set.seed(123)
res.mout <- Moutlier(df[,numeric_val_idx], quantile = 0.95, plot= FALSE)
par(mfrow=c(1,2))
plot(res.mout$md, col="lightblue", pch = 19, main = 'Detection of multivariable
outliers', xlab= 'Observation',
ylab ='Traditional Mahalanobis distance ')
abline(h = res.mout$cutoff, col = "red", lwd = 5, lty = 2)
plot(res.mout$rd, col="lightblue", pch = 19, xlab= 'Observation',
ylab ='Robust Mahalanobis distance ')
abline(h = res.mout$cutoff, col = "red", lwd = 5, lty = 2)
par(mfrow=c(1,1))
outliers = which(res.mout$md>res.mout$cutoff & res.mout$rd > res.mout$cutoff)
length(outliers)
length(outliers)/dim(df)[1]*100
# There are 344 multivariant outliers, about 5% of the individuals.
# Chunk 20
# After the report, we remove the newly created variables to don't interfere
# in the rest of the project
df$n.na <- NULL
df$n.errors <- NULL
df$n.outliers <- NULL
profiling(df[-1], df$Churn, "Churn")
